:PROPERTIES:
:ID:       ba9735bc-7791-465b-83bd-31e9440bb3b0
:END:
#+startup: latexpreview
#+startup: inlineimages showall
#+title: Matrični satovi

- proces umjesto vektora pamti matricu
  - $s.v[i][j]$ bilježi što proces $s.p$ u stanju $s$ zna o tome što proces $P_i$ zna o procesu $P_j$
    - npr. ako $(\forall i \le N)(s.v[i][s.p] > k)$, tada proces $s.p$ može zaključiti da svi procesi već znaju da je njegovo stanje veće od $k$
  - za skup od $N$ procesa služimo se $N \times N$ matricom

- Nakon što unutar poruke primi matricu $W$ nekog drugog procesa, naš proces ažurira svoju informaciju o vektorskim satovima svih ostalih procesa tako da uzme _maksimume_ po odgovarajućim komponentama

** Primjena
1. /garbage collection/

* Java primjer
#+begin_src java

public class MatrixClock {
    int[][] M;
    int myId;
    int N;

    public MatrixClock(int numProc, int id) {
        myId = id;
        N = numProc;
        M = new int[N][N];
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                M[i][j] = 0;
        M[myId][myId] = 1;
    }
    public void tick() {
        M[myId][myId]++;
    }
    public void sendAction() {
        //include the matrix in the message
        M[myId][myId]++;
    }
    public void receiveAction(int[][] W, int srcId) {
        // component-wise maximum of matrices
        for (int i = 0; i < N; i++)
            if (i != myId) {
                for (int j = 0; j < N; j++)
                    M[i][j] = Util.max(M[i][j], W[i][j]);
            }

    // update the vector for this process
        for (int j = 0; j < N; j++)
           M[myId][j] = Util.max(M[myId][j], W[srcId][j]);
        M[myId][myId]++;
    }
    public int getValue(int i, int j) {
        return M[i][j];
    }
}
#+end_src
