:PROPERTIES:
:ID:       8d30fd96-7dd0-4a40-b896-a32356b4db25
:END:
#+startup: latexpreview
#+startup: inlineimages showall
#+title: Lamportov Algoritam

- spada među algoritme za međusobno isključivanje koji su zasnovani na vremenskim žigovima

* Opis
- Svaki proces održava [[id:98080fa7-84bd-45bd-973c-a1be36b27e3d][logički sat]] (za vremensko žigosanje) (vektor $v$) i red (za spremanje zahtjeva za resursom) (vektor $q$)

- Algoritam osigurava da procesi ulaze u kritičnu sekciju u redoslijedu vremenskih žigova njihovih zahtjeva

- Pravila razmjene poruka izgledaju ovako
  * Da bi postavio zahtjev za kritičnom sekcijom, proces šalje *žigosanu poruku* /request/ svim drugim procesima, te dodaje taj zahtjev i žig u svoj red
  * Kad primi poruku /request/, proces sprema taj zahtjev i žig u svoj red, te šalje pošiljaocu *žigosanu poruku* /ack/
  * Da bi oslobodio kritičnu sekciju, proces šalje *žigosanu poruku* /release/ svim drugim procesima
  * Kad primi poruku /release/, proces briše odgovarajući zahtjev iz svog reda

- Proces ulazi u kritičnu sekciju ako
  * njegov zahtjev se nalazi u redu i ima žig $t$
  * taj $t$ je manji od žigova svih drugih zahtjeva u redu
  * primljena je barem po jedna poruka od svakog od preostalih procesa sa žigom većim od $t$

- _Pretpostavlja se FIFO uređaj poruka po komunikacijskim kanalima_

- Kao logički sat može se koristiti [[id:76ddab2b-ff62-4d2f-bdfc-4726d4a279a1][sat neposredne ovisnosti]]

- Budući da mogu postojati zahtjevi s istim vrijednostima žiga, uređaj preko žigova se proširuje do _totalnog leksikografskog_ uređaja korištenjem identifikatora procesa

[[file:./assets/pmf/distribuirano/slika_4_9.png]]


* Važna svojstva
- Korektnost se može dokazati pod pretpostavkom da su poruke uređene *u skladu s FIFO uređajem*
  - Naime, tada su ispunjena svojstva sigurnosti, odsustva izgladnjivanja i pravednosti

- Postoji vremenski pomak između trenutka postavljanja zahtjeva i trenutka ulaska u kritičnu sekciju, jer se čekaju odobrenja drugih procesa.

- Algoritam zahtijeva $3(N-1)$ poruka po svakom korištenju kritične sekcije: $N-1$ poruka /request/, $N-1$ poruka /ack/ i $N-1$ poruka /release/

- Algoritam zahtijeva prostor za pohranjivanje dva vektora $q$ i $v$ duljine $N$


* Java primjer

  #+begin_src java
  public class LamportMutex extends Process implements Lock {
      DirectClock v;
      int[] q; // request queue

      public LamportMutex(Linker initComm) {
          super(initComm);
          v = new DirectClock(N, myId);
          q = new int[N];
          for (int j = 0; j < N; j++)
              q[j] = Symbols.Infinity;
      }
      public synchronized void requestCS() {
          v.tick();
          q[myId] = v.getValue(myId);
          broadcastMsg("request", q[myId]);
          while (!okayCS())
              myWait();
      }
      public synchronized void releaseCS() {
          q[myId] = Symbols.Infinity;
          broadcastMsg("release", v.getValue(myId));
      }
      boolean okayCS() {
          for (int j = 0; j < N; j++){
              if (isGreater(q[myId], myId, q[j], j))
                  return false;
              if (isGreater(q[myId], myId, v.getValue(j), j))
                  return false;
          }
          return true;
      }
      boolean isGreater(int entry1, int pid1, int entry2, int pid2) {
          if (entry2 == Symbols.Infinity) return false;
          return ((entry1 > entry2)
                  || ((entry1 == entry2) && (pid1 > pid2)));
      }
      public synchronized void handleMsg(Msg m, int src, String tag) {
          int timeStamp = m.getMessageInt();
          v.receiveAction(src, timeStamp);
          if (tag.equals("request")) {
              q[src] = timeStamp;
              sendMsg(src, "ack", v.getValue(myId));
          } else if (tag.equals("release"))
              q[src] = Symbols.Infinity;
          notify(); // okayCS() may be true now
      }
  }
  #+end_src
